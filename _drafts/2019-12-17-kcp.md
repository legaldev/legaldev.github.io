---
layout: post
title: KCP 源码剖析
categories: c++
catalog: true
tags: [dev]
description: |
    KCP 源码剖析
figures: []
---
{% include asset_path %}

阅读本文之前，如果没听说过 KCP ，或者一点都不了解 KCP，麻烦抽一点时间先看看 KCP 项目的说明文档：[传送门](https://github.com/skywind3000/kcp)。本文的目的是深入 KCP 的实现细节去理解 KCP 。

## 什么是 KCP

KCP 是一个快速可靠协议，能够以比 TCP 更低的延迟来传送数据，数据重传更快，等待时间更短。

> TCP是为流量设计的（每秒内可以传输多少KB的数据），讲究的是充分利用带宽。而 KCP是为流速设计的（单个数据包从一端发送到一端需要多少时间），以10%-20%带宽浪费的代价换取了比 TCP快30%-40%的传输速度。TCP信道是一条流速很慢，但每秒流量很大的大运河，而KCP是水流湍急的小激流

以上是 KCP 文档上面写的，关键词是**带宽**和**流速**，KCP 会损耗带宽，带来的好处是更大更均衡的传输速率。更多的说明参考 KCP 自身的文档。

## 深入 KCP

KCP 源码在 `ikcp.h` 和 `ikcp.c` 里面，`ikcp.h` 核心的是数据结构的声明：

``` c++
//=====================================================================
// SEGMENT 一个 SETMENT 就是一个数据包
//=====================================================================
struct IKCPSEG
{
    struct IQUEUEHEAD node;     // 链表节点，发送和接受队列都是这里的链表的结构
    IUINT32 conv;               // 会话编号，同一个会话编号相同
    IUINT32 cmd;                // 数据包类型，譬如 DATA 或者 ACK
    IUINT32 frg                 // 由于 MTU 的限制，大数据包会拆分成多个小数据包，这个是小数据包的编号
    IUINT32 wnd;                // 每个数据包，都会附带上发送方的接受窗口大小
    IUINT32 ts;                 // 发送时间，如果是 ACK 包，会设置为源数据包的 ts
    IUINT32 sn;                 // 唯一标识数据包的编号
    IUINT32 una;                // 代表小于 una 的数据包都接收成功，跟 TCP 含义一致：oldest unacknowledged sequence number SND
    IUINT32 len;                //
    IUINT32 resendts;
    IUINT32 rto;
    IUINT32 fastack;
    IUINT32 xmit;
    char data[1];
};
```

以为统一称 SEGMENT 为数据包，是 KCP 协议处理数据的最小单位。


## KCP 的 ARQ 实现

## KCP 的 快速重传

## KCP 的 RTO 计算

## KCP 的 。。。
